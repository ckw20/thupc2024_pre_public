\frame
{
  \frametitle{B 一棵树 {by \itshape fzw}}

	树，选 $k$ 个点染黑，代价为边权求和，边权定义为两边子树黑色节点之差。
	
	$n,k\le 5\times 10^5$
}

\begin{frame}{正解}

	注意到当前询问形如权值为边权的权值求和，考虑树形 dp，直接的 dp 为 $f_{i,j}$ 表示 $i$ 子树内有 $j$ 个黑色节点的最小代价. \pause

	有转移是易于计算的，子树的合并是树形背包的合并 $f_{x,j+k}=\min(f_{x,j}+f_{to,k})$，考虑当前点 x 到父亲这条边的代价是多少. \pause

	注意到，形如如果当前子树有 $A$ 个黑点，子树外有 $k-A$ 个白点，代价为 $|2A-k|$.

\end{frame}

\begin{frame}{正解}

	观察函数的形式，你注意到如果将 $x$ 坐标作为黑点个数，$y$ 坐标作为代价，则每次代价增量为一个下凸函数，有树形背包合并不影响函数凸性. \pause

	注意到凸函数的维护可以尝试维护其差分数组，两个下凸函数做 $\min$ 卷积可以之际的视作差分数组的归并. \pause

	现在需要考虑的问题是往父亲方向的增量怎么处理.

\end{frame}

\begin{frame}{正解}

	考虑代价增量的差分，形如一段前缀差分为负数，一段后缀差分为正数，中间一个点根据 k 的奇偶性讨论是否存在差分 = 0. \pause

	有这一段前缀的长度总为定长度 $\lfloor \frac k 2 \rfloor$ 于是我们维护可并堆顶堆，使得左侧堆大小始终为前缀定长度，然后可以打加法标记实现. \pause

	总复杂度 $O(n\log n)$.

\end{frame}
